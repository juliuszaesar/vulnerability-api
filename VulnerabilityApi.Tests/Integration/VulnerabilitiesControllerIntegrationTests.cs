using System.Net;
using System.Net.Http.Headers;
using System.Net.Http.Json;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc.Testing;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using VulnerabilityApi.Data;
using VulnerabilityApi.Entities;
using Xunit.Abstractions;

namespace VulnerabilityApi.Tests.Integration;

public class VulnerabilitiesControllerIntegrationTests : IClassFixture<WebApplicationFactory<Program>>
{
    private readonly ITestOutputHelper _testOutputHelper;
    private readonly WebApplicationFactory<Program> _factory;
    private IConfiguration? _configuration;
    
    public VulnerabilitiesControllerIntegrationTests(WebApplicationFactory<Program> factory, ITestOutputHelper testOutputHelper)
    {
        _testOutputHelper = testOutputHelper;
        _factory = factory.WithWebHostBuilder(builder =>
        {
            builder.ConfigureAppConfiguration((_, config) =>
            {
                config.AddJsonFile("appsettings.json");
            });
                
            builder.ConfigureServices(services =>
            {
                // Remove current DataContext information
                var descriptor = services.SingleOrDefault(
                    d => d.ServiceType == typeof(DbContextOptions<DataContext>));

                if (descriptor != null)
                {
                    services.Remove(descriptor);
                }
                    
                // Add Test Database 
                services.AddDbContext<DataContext>(options =>
                {
                    options.UseInMemoryDatabase("VulnerabilityTestDatabase");
                });
                    
                var sp = services.BuildServiceProvider();
                _configuration = sp.GetRequiredService<IConfiguration>();

                using var scope = sp.CreateScope();
                var scopedServices = scope.ServiceProvider;
                var db = scopedServices.GetRequiredService<DataContext>();
                var userManager = scopedServices.GetRequiredService<UserManager<IdentityUser>>();

                db.Database.EnsureCreated();

                if (!db.Vulnerabilities.Any())
                {
                    db.Vulnerabilities.AddRange(
                        new Vulnerability
                        {
                            Id = "vulnerability--0c7b5b88-8ff7-4a4d-aa9d-feb398cd0001",
                            Name = "TestVulnerability1"
                        },
                        new Vulnerability
                        {
                            Id = "vulnerability--0c7b5b88-8ff7-4a4d-aa9d-feb398cd0002",
                            Name = "TestVulnerability2"
                        }
                    );
                    db.SaveChanges();
                } 
                // Add test user 
                var testUser = new IdentityUser { UserName = "testuser", Email = "testuser@testuser.com" };
                userManager.CreateAsync(testUser, "Testuserpassword!1").GetAwaiter().GetResult();
            });
        });
    }

    private async Task<string> GetAuthToken()
    {
        var client = _factory.CreateClient();
        var response = await client.PostAsJsonAsync("/auth/login", new
        {
            Username = "testuser",
            Password = "Testuserpassword!1"
        });
            
        response.EnsureSuccessStatusCode();
        var loginResult = await response.Content.ReadFromJsonAsync<LoginResult>();
        if (loginResult == null) throw new InvalidOperationException();
        _testOutputHelper.WriteLine($"Token: {loginResult.Token}");
        return loginResult.Token;
    }
        
    [Fact]
    public async Task GetVulnerabilities_ReturnsAllVulnerabilities()
    {
        // Arrange
        var client = _factory.CreateClient();
        var token = await GetAuthToken();
        client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", token);
            
        // Act
        var response = await client.GetAsync("/vulnerabilities");
            
        // Debugging integration test
        _testOutputHelper.WriteLine($"Response Status Code: {response.StatusCode}");
        _testOutputHelper.WriteLine($"Response Content: {await response.Content.ReadAsStringAsync()}");
        if (response.RequestMessage != null)
            _testOutputHelper.WriteLine($"Request URI: {response.RequestMessage.RequestUri}");

        // Assert
        Assert.Equal(HttpStatusCode.OK, response.StatusCode);
            
        var content = await response.Content.ReadAsStringAsync();
        _testOutputHelper.WriteLine($"Response content: {content}");
            
        var vulnerabilities = await response.Content.ReadFromJsonAsync<List<Vulnerability>>();
        Assert.NotNull(vulnerabilities);
        Assert.Equal(2, vulnerabilities.Count);
    }
}

public class LoginResult
{
    public LoginResult(string token)
    {
        Token = token;
    }

    public required string Token { get; init; }
}